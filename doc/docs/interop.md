---
id: Interop
title: Interop
---

## Representation

Repromise is built for maximum interop with JS promises. In fact, Repromises are ordinary JS `Promise`s at runtime:

```reason
Repromise.resolve(1) |> Js.log;
/* Promise { 1 } */

Js.Promise.resolve(1) |> Js.log;
/* Promise { 1 } */
```

The one exception is when nesting promises. In JS, nesting is not possible at all, because nested promises collapse:

```reason
Js.Promise.resolve(Js.Promise.resolve(1)) |> Js.log;
/* Promise { 1 } */
```

If not for collapsing, we would expect two levels of `Promise` here: `Promise { Promise { 1 } }`. But the two `Promise`s have been flattened into one. This makes it impossible to give a sound typing to ordinary JS promises. So, to prevent collapse, Repromise inserts a wrapper object:

```reason
Repromise.resolve(Repromise.resolve(1)) |> Js.log;
/* Promise { WrappedRepromise { wrapped: Promise { 1 } } } */
```

Repromise functions (such as [`wait`](API#wait) and [`then_`](API#then)) silently insert and remove this wrapper object, as needed.

### Takeaway

The most important takeaway from this is that in all cases that are possible in JS, Repromises have exactly the same representation.

Repromise just adds one more case, that cannot be generated by JS code, but can be generated on the Reason side by Repromise code, and that is the case of nested Repromises with a wrapper object in between them to prevent collapse.

<br/>

## Creating a binding

So, any JS function that returns a promise already returns a valid Repromise. Let's use this to write a binding to [`node-fetch`](https://www.npmjs.com/package/node-fetch):

```
type response;

[@bs.module]
external fetch: string => Repromise.t(response) = "node-fetch";

[@bs.send]
external text: response => Repromise.t(string) = "";
```

We can test it with:

```reason
let url =
  "https://raw.githubusercontent.com/"
  ++ "aantron/repromise-example-bsb/master/main.re";

let () =
  fetch(url)
  |> Repromise.then_(text)
  |> Repromise.wait(Js.log);
```

This downloads and prints `main.re` from the [Repromise example repo](https://github.com/aantron/repromise-example-bsb).

A complete version of the above example, with all boilerplate, is in the [binding example repo](https://github.com/aantron/repromise-example-binding).

<br/>

## Promises resolved with multiple types

Some JS APIs may resolve promises with values of different types, taking advantage of the dynamic "typing" of JS. In such cases, you can do this:

```reason
/* An abstract type for the promise value. */
type stringOrInt;

/* Use the abstract type to write the binding. */
[@bs.val]
external foo: unit => Repromise.t(stringOrInt) = "";

/* Neither the abstract type, nor the binding foo, should be exposed to the
   users (that is, in the .rei for the binding). Instead, wrap foo in a
   function that checks the type, and converts all the possibilities to
   values of one type. In this case, we will use a variant: */
let foo = () =>
  foo()
  |> Repromise.map(value =>
    switch (Js.Types.reify_type(value)) {
    | (Js.Types.String, s) => `String(s)
    | (Js.Types.Int, i) => `Int(i)
    | _ => assert(false)
    });
```

<br/>

## Rejection

JS APIs often reject promises. To bind to these, you can use the [`Repromise.Rejectable`](RejectableAPI) API.

If the JS API rejects promises with rejections of only one type, you can use that type directly in the binding. In the made-up example below, the rejection type is `string`:

```reason
[@bs.val]
external foo: unit => Repromise.Rejectable.t(int, string) = "";
```

Rejectable Repromises should not be exposed to users of bindings. Instead, rejections should be converted into explicit error handling (often [`Belt.Result`](https://bucklescript.github.io/bucklescript/api/Belt.Result.html)) using [`Repromise.Rejectable.catch`](RejectableAPI#catch):

```reason
[@bs.val]
external foo: unit => Repromise.Rejectable.t(int, string) = "";

let foo = () =>
  foo()
  |> Repromise.Rejectable.map(value =>
    Belt.Result.Ok(value))
  |> Repromise.Rejectable.catch(error =>
    Repromise.resolve(Belt.Result.Error(error)))
/* The final promise has type Repromise.t(Belt.Result.t(int, string)) */
```

Please let us know what helpers should be added to Repromise, to make these conversions easier.

If the JS API can reject with values of multiple JS types, this can be handled as in [Promises resolved with multiple types](#promises-resolved-with-multiple-types), except that the `Js.Types.reify_type` call should be placed into `catch` instead of `map`.

<br/>

## Passing promises to JS

In most cases, binding to JS APIs that take promises as arguments works as one might expect:

```reason
[@bs.val]
external foo: Repromise.t(int) => unit = "";
```

JS APIs should never ask for nested promises, because JS promises don't support nesting anyway. So, we don't expect that there will be a JS API that needs a type signature like this:

```reason
[@bs.val]
external foo: Repromise.t(Repromise.t(int)) => unit = "";
```

However, there is the [possibility](https://github.com/aantron/repromise/issues/8) of a JS API that can accept promises of any type:

```reason
[@bs.val]
external foo: Repromise.t('a) => unit = "";
```

In this case, it will be possible to pass a nested Repromise to the JS API. Repromise can support this, but we ask that you please let us know if you run into such a JS API by an [opening an issue](https://github.com/aantron/repromise/issues). That way, we can design something appropriate for the case. What we suspect is that all such JS APIs will actually be promise-manipulation libraries, that will have to be reimplemented as helper libraries for Repromise, the same way Repromise is a reimplementation of JS `Promise` functions.

<br/>
